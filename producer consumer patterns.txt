--Producer-Consumer models---
There are four types of producer-consumer models to consider when designing a 
thread-safe queue.

1. Single Producer, Multiple Consumer (SPMC)
2. Multiple Producer, Single Consumer (MPSC)
3. Multiple Producer, Multipler Consumer (MPMC)
4. Single Producer, Single Consumer (SPSC)

The work-stealing queue fits the SPMC model. Since multiple threads can remove from the queue,
and only the owner thread can add into the queue, there are multiple consumers, and one producer.

--Overview---------------------
A work stealing queue is composed of three key operations: push, pop, and steal. 
Pushes and pops happen at the tail-end of the queue (elements removed LIFO), and steals happen
at the head of the queue (elements removed FIFO). All intermediate
operations are ATOMIC; any actions made by a thread onto an atomic variable will be VISIBLE and
INSTANTANEOUS by any other thread with access to the same variable. 

--Regarding Access and Races----
Only the owner thread has access to the push and pop operations, so it's impossible for 
the two operations to happen concurrently; the tail-end is safe from data races 
to the same variable. However, it is possible for the owner thread to execute a push or pop, 
while another thread executes a steal. 

--Push-Steal--------------------
Consider a data race between a push operation and a steal operation. The worst thing that can happen 
in a push-steal is that a steal returns an empty element. If the steal operation happens before the push, 
then steal returns nothing. If the push operation happens before the steal however, then steal will return 
the pushed element. Therefore, even without explicitly written protections, concurrent access to the same
element through a push-steal is safe. 

--Pop-Steal---------------------
In a pop-steal, the queue is safe from data races as long as there is more than 1 element left in the queue.
Because steals happen at the head, and pops happen at the tail, a simultaeneous steal and pop will 
remove different elements. When a steal and pop try to remove the same element, undefined behavior occurs. 
One way to solve this is to store locally the indeces when doing checks, then check the atomic value of 
the indeces before removing elements.  
